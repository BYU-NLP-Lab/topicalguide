/*
 * All of the following models are independent of the rest of the system.
 * Some of the models may depend upon eachother, but none should depend 
 * upon anything outside this file with the exception of libraries.
 * 
 * Dependencies:
 * - backbone.js
 */


// Helper function to pull out information such as readable_name, description, and anything else
var extractMetadata = function(hash, metadata, defaults) {
    for(key in defaults) {
        if(key in metadata) {
            hash[key] = metadata[key];
            delete metadata[key];
        } else {
            hash[key] = defaults[key];
        }
    }
}

/* 
 * Helper function to pull out a deeply nested sub-hash.
 * name - One of: datasets, analyses, topics
 * Return sub-hash if found; empty hash otherwise.
 */
var extractSubHash = function(name, hash) {
    var list = ["datasets", globalSelectionModel.get("dataset"), "analyses",
                globalSelectionModel.get("analysis"), "topics"];
    for(i=0; i<list.length; i++) {
        hash = hash[list[i]];
        if(list[i] === name) break;
    }
    return hash;
}


/*
 * The DataModel is responsible for managing the dataset and analysis data locally.
 * The localStorage variable is used so other browser windows will have the same data available to them.
 * Each item should have 4 states for data requests, "loaded", "unloaded", "loading", "error".
 */
var DataModel = Backbone.Model.extend({
    
    /* 
     * The query should be a url fragment of the form "api?datasets=...".
     * TODO, make the query a hash and the url is autogenerated (and normalized).
     * TODO, queries that are too long use POST instead of GET
     */
    requestData: function(query) {
        var hash = {};
        if(query in localStorage) {
            hash[query] = "loaded";
            this.set(hash);
        } else {
            hash[query] = "loading";
            this.set(hash);
            var that = this;
            d3.json(query, function(data) {
                localStorage[query] = JSON.stringify(data);
                hash[query] = "loaded";
                that.set(hash);
            });
        }
    },
    
    /*
     * Returns the parsed data stored at the given url.
     * If there is no data then an empty hash is returned.
     */
    getData: function(query) {
        if(query in localStorage) {
            return JSON.parse(localStorage[query]);
        } else {
            return {};
        }
    },
    
    /*
     * Submit a query to the server, the request hash is turned into a normalized url to ensure that
     * requests look the same when submitted.
     * request - A hash containing the properties being requested.
     * dataReadyCallback - The function called upon success.
     * errorCallback - The function called if there is an error message in the returned data.
     * TODO make this be able to sort values that are arrays and not just strings.
     */
    submitQueryByHash: function(request, dataReadyCallback, errorCallback) {
        var fragments = [];
        for(key in request) {
            fragments.push(key + "=" + request[key]);
        }
        fragments.sort();
        var url = "api?" + fragments.join("&");
        this.submitQueryByUrl(url, dataReadyCallback, errorCallback);
    },
    
    /*
     * Submit a query to the server for json formatted data.
     * url - The url where the data is found.
     * dataReadyCallback - The function called upon success.
     * errorCallback - The function called if there is an error message in the returned data.
     */
    submitQueryByUrl: function(url, dataReadyCallback, errorCallback) {
        console.log(url);
        if(url in localStorage) {
            dataReadyCallback(JSON.parse(localStorage[url]));
        } else {
            d3.json(url, function(data) {
                if(data === undefined || data === null || "error" in data) {
                    errorCallback(data["error"]);
                } else {
                    localStorage[url] = JSON.stringify(data);
                    dataReadyCallback(data);
                }
            });
        }
    },
    
    
});
var globalDataModel = new DataModel();

/*
 * The SettingsModel stores visualization specific settings for things like sliders.
 */
var SettingsModel = Backbone.Model.extend({
    /*
     * Get the items listed in the defaults hash.
     * defaults - Hash with defaults in case the key could not be found in this model.
     * Return hash with either the value, if found, or the default value from the defaults hash.
     */
    getWithDefaults: function(defaults) {
        var hash = {};
        for(key in defaults) {
            if(this.has(key)) {
                hash[key] = this.get(key);
            } else {
                hash[key] = defaults[key];
            }
        }
        return hash;
    },
});
var globalSettingsModel = new SettingsModel();

/*
 * The FilterModel tracks filters the user creates, this includes things such as word lists, 
 * max number of important words, etc.
 */
var FilterModel = Backbone.Model.extend({
    
    /*
     * Get the items listed in the defaults hash.
     * defaults - Hash with defaults in case the key could not be found in this model.
     * Return hash with either the value, if found, or the default value from the defaults hash.
     */
    getWithDefaults: function(defaults) {
        var hash = {};
        for(key in defaults) {
            if(this.has(key)) {
                hash[key] = this.get(key);
            } else {
                hash[key] = defaults[key];
            }
        }
        return hash;
    },
});
var globalFilterModel = new FilterModel();

/*
 * The Selection Model is responsible for tracking which specific topic(s), document(s), or word(s) 
 * are selected.
 */
var SelectionModel = Backbone.Model.extend({
    
    availableSelections: ["dataset", "analysis", "topic", "document", "word"],
    
    initialize: function() {
        var hash = {};
        for(i=0; i < this.availableSelections.length; i++) {
            hash[this.availableSelections[i]] = "";
        }
        this.set(hash);
    },
    
    /*
     * Ensure that the given items are non-empty strings.
     * Return true if they are non-empty; false otherwise.
     */
    nonEmpty: function(list) {
        for(i=0; i<list.length; i++) {
            if(this.get(list[i]) === "") {
                return false;
            }
        }
        return true;
    },
    
    getListed: function(list) {
        var hash = {};
        for(i=0; i<list.length; i++) {
            if(this.has(list[i])) {
                hash[list[i]] = this.get(list[i]);
            }
        }
        return hash;
    },
});
var globalSelectionModel = new SelectionModel();


